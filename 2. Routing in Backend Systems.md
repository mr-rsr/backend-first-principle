# Routing in Backend Systems: Designing the “Where” of an HTTP Request

## Introduction

Every backend system eventually answers the same question: *given this request, what code should run*?

HTTP methods already tell the server **what** the client intends to do. Routing answers the complementary question: **where** that intent should be applied. Without a clear routing model, backend codebases degrade into brittle conditionals, ambiguous endpoints, and accidental breaking changes.

This article builds a mental model for routing that holds across languages, frameworks, and architectures. It focuses on how routing shapes API semantics, how production systems actually use it, and where experienced engineers still get it wrong.

---

## Mental Model: Routing as Intent Addressing

Think of an HTTP request as two orthogonal signals:

* **Intent**: expressed by the HTTP method (`GET`, `POST`, `PUT`, `DELETE`)
* **Target**: expressed by the route (the URL path)

Routing exists to bind those two signals to a specific handler.

The backend does not “handle a URL” or “handle a method” in isolation. It handles the **combination** of method + path. That pair forms a unique address for behavior.

Conceptually:

```
(method, path) → handler → business logic → response
```

Everything else in routing builds on this idea.

---

## Core Concepts

### Static Routes

**What they are**
Static routes have a fixed path with no variable segments.

```
GET /api/books
POST /api/books
```

**Why they exist**
They represent stable resources or collections. Their meaning does not depend on client-supplied identifiers.

**How they appear in real APIs**

* Listing resources
* Creating new resources
* Triggering idempotent operations

**Common misuse**
Overloading static routes with too many responsibilities. For example, stuffing filtering, searching, and pagination logic into unrelated static endpoints instead of expressing intent cleanly.

**Alternatives**
When the resource identity matters, use path parameters. When behavior varies based on input, use query parameters.

---

### Method + Route as a Composite Key

A frequent misconception is that routes must be unique by path alone. In practice, **method and path together define uniqueness**.

```
GET  /api/books   → fetch collection
POST /api/books  → create resource
```

These do not conflict. They intentionally map to different handlers.

**Why this matters**
It keeps APIs semantically compact. You avoid artificial endpoints like `/createBook` or `/getBooks`, which encode intent redundantly.

**Anti-pattern**
Encoding actions in paths instead of methods.

```
POST /api/create-book   ❌
GET  /api/delete-book  ❌
```

---

### Dynamic Routes (Path Parameters)

**What they are**
Routes with variable segments, typically written as placeholders.

```
GET /api/users/{id}
```

**Why they exist**
They express *identity*. The path answers *which* resource the intent applies to.

**Real-world usage**

* Fetching a specific entity
* Updating or deleting a known resource

**Important property**
Path parameters are always strings at the routing layer. Validation and typing belong in application logic, not routing.

**Misuse to watch for**
Using path parameters to represent arbitrary input instead of identity.

```
GET /api/search/{query}   ❌
```

This damages semantic clarity and makes evolution painful.

---

### Query Parameters

**What they are**
Key-value pairs appended after `?` in the URL.

```
GET /api/search?query=distributed+systems
```

**Why they exist**
They carry **metadata about the request**, not the identity of a resource.

**Common use cases**

* Filtering
* Sorting
* Pagination
* Optional modifiers

**Why not use the request body?**
By convention and tooling expectations, `GET` requests do not carry bodies. Query parameters fill that gap.

**Anti-pattern**
Encoding core resource identity in query parameters.

```
GET /api/users?id=123   ❌
```

If the request is about a specific user, the path should say so.

---

### Nested Routes

**What they are**
Routes that express relationships between resources by hierarchy.

```
GET /api/users/{userId}/posts/{postId}
```

**Why they exist**
They communicate *context*. The route reads like a sentence describing the data relationship.

**How they scale in real systems**

* One level deep is common and clear
* Multiple levels are acceptable when relationships are strict and meaningful

**Hidden cost**
Deep nesting increases coupling. Changing parent-child relationships later becomes harder.

**Alternative pattern**
Flatten routes when relationships are loose, and express association via query parameters.

---

### Route Versioning and Deprecation

**What it is**
Embedding an API version into the route.

```
/api/v1/products
/api/v2/products
```

**Why it exists**
APIs evolve. Some changes are incompatible. Versioning creates a controlled migration path.

**Production reality**

* Old versions remain live longer than expected
* Deprecation windows must be explicit and enforced

**Common mistake**
Versioning too early or for non-breaking changes. Versions should represent *contract changes*, not refactors.

**Alternatives**

* Header-based versioning
* Content negotiation

These can work but are often harder to debug and document.

---

### Catch-All Routes

**What they are**
A final fallback that matches any request not handled earlier.

**Purpose**

* Return consistent “not found” responses
* Avoid silent failures or default framework behavior

**Why ordering matters**
Catch-all routes must be evaluated last. Otherwise, they shadow valid routes.

**Anti-pattern**
Returning generic success responses from catch-all handlers. Errors should be explicit.

---

## Practical API Examples

### Resource Collection vs Resource Identity

```
GET  /api/books        → list books
POST /api/books        → create book
GET  /api/books/42     → fetch book 42
```

### Query Parameters for Metadata

```
GET /api/books?page=2&limit=20&sort=price_desc
```

The route identifies *what* is being accessed. The query refines *how*.

### Nested Context

```
GET /api/users/123/posts
GET /api/users/123/posts/456
```

Each level adds semantic precision without inventing new verbs.

---

## Common Pitfalls and Trade-offs

* Treating routes as implementation details instead of public contracts
* Overusing nesting to model database relationships
* Encoding behavior into paths instead of methods
* Ignoring deprecation planning until clients break
* Allowing ambiguous routes that differ only by optional parameters

Routing decisions are hard to undo once clients depend on them.

---

## Real-World Backend Patterns

* Large systems standardize routing conventions early
* Teams document route semantics more rigorously than handler logic
* API gateways often enforce routing policies independently of services
* Monoliths and microservices share the same routing principles

Routing is one of the few backend concepts that remains stable across stacks.

---

## FAQ

**Why not put everything in the request body?**
Because routing is about *addressing*. Bodies describe payloads, not targets.

**How deep should nesting go?**
As deep as the semantic relationship is strong and stable. Rarely more than two levels.

**Is versioning always required?**
Only for breaking changes. Avoid version churn.

**Can query parameters replace path parameters?**
Technically yes. Semantically no.

**Should routing logic contain business rules?**
No. Routing selects handlers. Business logic belongs inside them.

---

## Conclusion

Routing defines how intent meets structure. It is not about URLs or frameworks. It is about making backend behavior predictable, readable, and evolvable.

When routes clearly express identity, context, and intent, the rest of the system becomes easier to reason about.
